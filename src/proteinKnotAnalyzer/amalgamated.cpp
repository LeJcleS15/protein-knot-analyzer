/*
 * @name Protein Knot Analyzer
 * @author Brad Lee
 * @version 1.00
 * @license GNU LGPL v3
 * @brief Visual and extended visualization tools for detecting protein knots.
 * @details A library providing the analysis and visualization tools for detecting protein knots meant
 * for a graphical interface.
 *
 * Works Cited:
 * Taylor, W. A deeply knotted protein structure and how it might fold.
 * Nature 406, 916-919 (2000) doi:10.1038/35022623
 */

#include "proteinKnotAnalyzer/amalgamated.h"

/*
 * PKA = Protein Knot Analyzer
 */
namespace PKA {

void MMDBAndCarbonAlphaMatrix::setMMDBModel(
		std::unique_ptr<CMMDBManager> MMDBPtr, int modelId, cpstr chainId) {
	ModelPtr_ = std::move(MMDBPtr);
	modelId_ = modelId;
	chainId_ = chainId;
}

void MMDBAndCarbonAlphaMatrix::setMatrix(
		std::unique_ptr<PKD::DoubleMatrix> matrixPtr) {
	matrix_ = std::move(matrixPtr);
}
std::unique_ptr<CMMDBManager> MMDBAndCarbonAlphaMatrix::getModel() {
	return std::move(ModelPtr_);
}
std::unique_ptr<PKD::DoubleMatrix> MMDBAndCarbonAlphaMatrix::getMatrix() {
	return std::move(matrix_);
}
std::unique_ptr<PKD::DoubleMatrix> MMDBAndCarbonAlphaMatrix::toMatrix() {
	int ir, ia, iCA;
	int nResidues, nAtoms;
	std::size_t nCA;
	std::unique_ptr<PKD::DoubleMatrix> matrix;
	CChain *chain;
	CResidue **residueTable;
	CAtom **atomTable;

	//  get chain
	printf("Getting Chain...\n");
	chain = ModelPtr_->GetChain(modelId_, chainId_);
	nCA = 0;
	// get residue table for current chain:
	chain->GetResidueTable(residueTable, nResidues);
	printf("Total Residues In Chain#%s Model#%d: %d\n", chainId_, modelId_,
			nResidues);
	// loop over all residues in current chain:
	for (ir = 0; ir < nResidues; ir++) {
		if (residueTable[ir]) {
			residueTable[ir]->GetAtomTable(atomTable, nAtoms);
			/*printf("Total Atoms In Residue#%d Chain#%s Model#%d: %d\n", ir,
			 chainId_, modelId_, nAtoms);*/
			for (ia = 0; ia < nAtoms; ia++) {
				// atom exists
				if (atomTable[ia]) {
					if (strcmp((const char*) atomTable[ia]->name, " CA ")
							== 0) {
						nCA++;
					}
				}
			}
		}
	}

// create empty matrix with the carbon atom size
	matrix = std::make_unique<PKD::DoubleMatrix>(nCA);
// now get the coordinates
	iCA = 0;
	// get residue table for current chain:
	chain->GetResidueTable(residueTable, nResidues);
	// loop over all residues in current chain:
	for (ir = 0; ir < nResidues; ir++) {
		if (residueTable[ir]) {
			residueTable[ir]->GetAtomTable(atomTable, nAtoms);
			for (ia = 0; ia < nAtoms; ia++) {
				// atom exists
				if (atomTable[ia]) {
					if (strcmp((const char*) atomTable[ia]->name, " CA ")
							== 0) {
						matrix->m[iCA] = atomTable[ia]->x;
						matrix->m[iCA + 1] = atomTable[ia]->y;
						matrix->m[iCA + 2] = atomTable[ia]->z;
						/*printf("%f %f %f\n", atomTable[ia]->x,
						 atomTable[ia]->y, atomTable[ia]->z);*/
						iCA += 3;
					}
				}
			}
		}
	}

	return matrix;
}

std::unique_ptr<CMMDBManager> MMDBAndCarbonAlphaMatrix::toMMDB() {
	int RC, iResidue, modelId, bondReturn1, bondReturn2;
	cpstr chainId;
	CAtom *atom, *atomLast;
	std::unique_ptr<CMMDBManager> MMDB = std::make_unique<CMMDBManager>();
	/*
	 * check matrix is set
	 */
	if (!matrix_) {
			printf("Error: Alpha Carbon Matrix not set\n");
			return {};
		}
	if (MMDB_template) {
		/*
		 * file template
		 */
		printf("Importing template PDB file %s...\n",
				MMDB_templatePath.c_str());
		RC = MMDB->ReadPDBASCII(MMDB_templatePath.c_str());
		if (RC) {
			printf("Error #%i: %s\n", RC, GetErrorDescription(RC));
			return {};
		} else {
			printf("Import Template SUCCESS\n");
		}
	} else {
		MMDB->PutPDBString("COMPND    UNNAMED");
		MMDB->PutPDBString("AUTHOR    GENERATED BY PROTEIN KNOT DETECTOR 1.00");
	}

	CModel *model = new CModel();
	MMDB->AddModel(model);
	modelId = model->GetSerNum();
	CChain *chain = new CChain();
	chainId = "A";
	chain->SetChainID(chainId);
	model->AddChain(chain);
	iResidue = 1; // Count Residues
    for (size_t i = 0; i < matrix_->n; i += 3) {
		/* the residue IS NOT associated with MMDB */
        CResidue *residue = new CResidue();
		residue->SetResID("ALA", iResidue, "");
        atom = new  CAtom();
		atom->SetAtomName(" CA ");  // it has to be a PDB name!
		atom->SetElementName("C");
		/* In the PDB file format,
		 * each atom is given not only X, Y, and Z Cartesian coordinates,
		 * but two additional values immediately following
		 * called occupancy and temperature value
		 */
		atom->SetCoordinates(matrix_->m[i], matrix_->m[i + 1],
				matrix_->m[i + 2], 1.0, 1.0);
		/*printf("%f %f %f\n", matrix_->m[i], matrix_->m[i + 1],
		 matrix_->m[i + 2]);*/
        //RC = residue->AddAtom(atom);
		if (RC <= 0) {
			// this may happen only if you try to add the same atom twice.
			printf("Error adding atom #%I64d\n", i);
		}
		chain->AddResidue(residue);
		atomLast = atom;
		iResidue++;
	}
	MMDB->PDBCleanup(
	PDBCLEAN_SERIAL | PDBCLEAN_INDEX);
	// MMDB->FinishStructEdit();
	/*
	 * Now we add bonds. We must do this after establishing the coordinate hierarchy
	 * because pointers obtained from CMMDBManager must be used.
	 */
	int ir;
	int nResidues;
	CResidue **residueTable;
	atomLast = nullptr;
	//  get chain
	printf("Getting Chain using modelId#%d chainId#%s\n", modelId,
			(char*) chainId);
	chain = MMDB->GetChain(modelId, chainId);
	// get residue table for current chain:
	chain->GetResidueTable(residueTable, nResidues);
	// loop over all residues in current chain:
	for (ir = 0; ir < nResidues; ir++) {
		if (residueTable[ir]) {
			atom = residueTable[ir]->GetAtom(0);
			if (atom) {
				if (atomLast != nullptr) {
					bondReturn1 = atom->AddBond(atomLast, 1);
					bondReturn2 = atomLast->AddBond(atom, 1);
					if (bondReturn1 && bondReturn2) {
						/*printf("OK #%d %f\n", ir, atom->x);*/
					} else {
						printf("ERROR #%d %f\n", ir, atom->x);
					}
				}
				atomLast = atom;
			}
		}
	}
	return MMDB;
}

int OCCT_Shape::writeSTEP(char *path) {
	STEPControl_Writer writer;
	if (!Interface_Static::SetIVal("write.precision.mode", 1)) {
		//error
	}
	if (!Interface_Static::SetIVal("write.step.assembly", 0)) {
		//error
	}
	if (!Interface_Static::SetCVal("write.step.schema", "DIS")) {
		//error
	}

	// Write file
	STEPControl_StepModelType mode = STEPControl_AsIs;
	//XCAFDoc_ColorTool colorTool;
	//opencascade::handle<XSControl_WorkSession> WS;
	//writer.SetWS(WS,false);
	IFSelect_ReturnStatus stat1 = writer.Transfer(*shape_, mode);
	IFSelect_ReturnStatus stat2 = writer.Write(path);
	return 0;
}

void CarbonAlphaMatrixAndOCCT_Shape::setMatrix(
		std::unique_ptr<PKD::DoubleMatrix> matrixPtr) {
	matrixPtr_ = std::move(matrixPtr);
}
std::unique_ptr<OCCT_Shape> CarbonAlphaMatrixAndOCCT_Shape::getShape() {
	return std::move(shapePtr_);
}
std::unique_ptr<PKD::DoubleMatrix> CarbonAlphaMatrixAndOCCT_Shape::getMatrix() {
	return std::move(matrixPtr_);
}
void CarbonAlphaMatrixAndOCCT_Shape::toShape() {
	shapePtr_ = std::make_unique<OCCT_Shape>();
	std::unique_ptr<gp_Pnt> pntCurrentPtr, pntLastPtr;
	// Start building the compound
	std::unique_ptr<TopoDS_Compound> shape =
			std::make_unique<TopoDS_Compound>();
	BRep_Builder aBuilder;
	aBuilder.MakeCompound(*shape);
	// Fill compound with lines
	for (size_t i = 0; i < matrixPtr_->n; i += 3) {
		pntCurrentPtr = std::make_unique<gp_Pnt>(matrixPtr_->m[i],
				matrixPtr_->m[i + 1], matrixPtr_->m[i + 2]);
		if (pntLastPtr) {
			TopoDS_Edge edge = BRepBuilderAPI_MakeEdge(*pntCurrentPtr,
					*pntLastPtr);
			aBuilder.Add(*shape, edge);
		}
		pntLastPtr = std::move(pntCurrentPtr);
	}
	// Done building
	shapePtr_->shape_ = std::move(shape);
}

} // namespace PKA
